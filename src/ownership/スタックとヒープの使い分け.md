# スタックとヒープの使い分けガイド

## 基本的な考え方

Rustでは、データの保存場所（スタックかヒープか）を適切に選択することが、パフォーマンスとメモリ効率に大きく影響します。

## スタックを選ぶべき場面

### 1. サイズが固定で小さいデータ

```rust
// 2D座標のような小さな構造体
struct Point2D {
    x: f32,
    y: f32,
}
let p = Point2D { x: 10.0, y: 20.0 };  // 8バイトのみ

// RGB色情報
#[derive(Copy, Clone)]
struct Color {
    r: u8, g: u8, b: u8, a: u8,
}
let color = Color { r: 255, g: 0, b: 0, a: 255 };  // 4バイトのみ
```

### 2. 一時的な計算結果

```rust
// 計算結果を直接返す
fn calculate_area(width: f32, height: f32) -> f32 {
    width * height  // スタック上で計算
}

// 簡単な判定結果
fn is_valid_age(age: u8) -> bool {
    age >= 18 && age <= 100
}
```

### 3. 固定サイズの設定値

```rust
// コンパイル時定数
const MAX_BUFFER_SIZE: usize = 1024;
const DEFAULT_PORT: u16 = 8080;

// 固定サイズ配列
let buffer: [u8; 256] = [0; 256];  // 256バイトの固定配列
let lookup_table: [f32; 10] = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9];
```

### 4. パフォーマンスが重要な場合

```rust
// ゲームエンジンでの座標計算
#[derive(Copy, Clone)]
struct Vector3 {
    x: f32, y: f32, z: f32,
}

// 高頻度で作成・破棄される小さなデータ
fn update_positions(positions: &mut [Vector3], velocity: Vector3, delta_time: f32) {
    for pos in positions {
        pos.x += velocity.x * delta_time;
        pos.y += velocity.y * delta_time;
        pos.z += velocity.z * delta_time;
    }
}
```

## ヒープを選ぶべき場面

### 1. サイズが実行時に決まる場合

```rust
// ファイル読み込み（サイズ不明）
fn read_file_contents(path: &str) -> String {
    std::fs::read_to_string(path).unwrap()
}

// ユーザー入力の受け取り
fn get_user_input() -> String {
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();
    input.trim().to_string()
}

// 動的なコレクション作成
fn generate_numbers(count: usize) -> Vec<i32> {
    (0..count).collect()
}
```

### 2. 大きなデータ構造

```rust
// 画像データ
struct Image {
    pixels: Vec<u8>,  // 数MB〜数GBになる可能性
    width: u32,
    height: u32,
}

// 大量のログデータ
struct LogBuffer {
    entries: Vec<String>,
    max_size: usize,
}

// データベースのレコード
struct UserDatabase {
    users: Vec<User>,
    indexes: HashMap<String, usize>,
}
```

### 3. 所有権を転送する必要がある場合

```rust
// 関数間でデータを受け渡し
fn create_user_list() -> Vec<String> {
    let mut users = Vec::new();
    users.push(String::from("Alice"));
    users.push(String::from("Bob"));
    users  // 所有権を呼び出し元に転送
}

// スレッド間でのデータ共有
use std::thread;
fn spawn_worker(data: Vec<i32>) -> thread::JoinHandle<Vec<i32>> {
    thread::spawn(move || {
        // dataの所有権がスレッドに移動
        data.iter().map(|x| x * 2).collect()
    })
}
```

### 4. 再帰的・自己参照的なデータ構造

```rust
// 二分木
enum Tree {
    Leaf(i32),
    Node(Box<Tree>, Box<Tree>),  // Boxがないとサイズが無限大に
}

// 連結リスト
struct ListNode {
    value: i32,
    next: Option<Box<ListNode>>,
}

// グラフ構造
struct GraphNode {
    id: usize,
    edges: Vec<usize>,  // 他のノードへの参照
}
```

## 実践的な例

### データベースから取得したデータ

```rust
// DBから取得するデータは基本的にヒープに格納

// 1. 単一レコードの取得
struct User {
    id: i64,                    // スタック：固定サイズ
    name: String,               // ヒープ：可変長文字列
    email: String,              // ヒープ：可変長文字列
    profile: Option<String>,    // ヒープ：NULL可能な可変長データ
    created_at: i64,           // スタック：タイムスタンプ
}

// 2. 複数レコードの取得
fn get_users_from_db() -> Vec<User> {
    // ヒープ：レコード数は実行時に決まる
    let mut users = Vec::new();
    
    // DB接続・クエリ実行（擬似コード）
    // for row in db.query("SELECT * FROM users") {
    //     users.push(User::from(row));
    // }
    
    users
}

// 3. 大量のデータを扱う場合
struct QueryResult {
    // ヒープ：可変長のレコードリスト
    rows: Vec<HashMap<String, Value>>,
    
    // スタック：メタデータ
    total_count: usize,
    page: u32,
    per_page: u32,
}

// 4. BLOB/CLOBデータ
struct Document {
    id: i64,
    title: String,
    content: Vec<u8>,        // ヒープ：バイナリデータ（画像、PDF等）
    metadata: String,        // ヒープ：JSON等のメタデータ
}
```

### なぜDBデータは主にヒープなのか

```rust
// 1. レコード数が動的
fn search_products(keyword: &str) -> Vec<Product> {
    // 検索結果の件数は実行時まで不明
    database::query("SELECT * FROM products WHERE name LIKE ?", keyword)
}

// 2. データサイズが可変
struct Article {
    id: i64,
    // 記事の長さは1文字から数万文字まで様々
    content: String,
    // タグの数も記事により異なる
    tags: Vec<String>,
}

// 3. NULL値の扱い
struct Employee {
    id: i64,
    name: String,
    // 電話番号はNULLの可能性
    phone: Option<String>,
    // 上司IDもNULLの可能性
    manager_id: Option<i64>,
}

// 4. JOIN結果の複雑な構造
struct OrderWithDetails {
    order: Order,
    // 注文明細の数は注文により異なる
    items: Vec<OrderItem>,
    // 顧客情報
    customer: Customer,
}
```

### 効率的なDB データの扱い方

```rust
// ✅ 必要なフィールドのみ取得
fn get_user_names() -> Vec<String> {
    // SELECT name FROM users （全カラムではなく必要なものだけ）
    database::query_column("SELECT name FROM users")
}

// ✅ ページネーション
fn get_users_paginated(page: u32, per_page: u32) -> Vec<User> {
    let offset = (page - 1) * per_page;
    // LIMIT/OFFSETで必要な分だけ取得
    database::query(&format!(
        "SELECT * FROM users LIMIT {} OFFSET {}", 
        per_page, offset
    ))
}

// ✅ ストリーミング処理
fn process_large_dataset() {
    // 一度に全データをメモリに載せない
    let mut cursor = database::query_cursor("SELECT * FROM large_table");
    
    while let Some(row) = cursor.next() {
        process_row(row);  // 1行ずつ処理
    }
}

// ❌ 非効率：不要なデータまで取得
fn inefficient_get_users() -> Vec<User> {
    // SELECT * で全カラム取得（使わないカラムも含む）
    database::query("SELECT * FROM users")
}
```

### キャッシュ戦略

```rust
use std::collections::HashMap;
use std::sync::Arc;

// アプリケーションレベルのキャッシュ
struct UserCache {
    // ヒープ：キャッシュデータ
    // Arc for thread-safe sharing
    cache: HashMap<i64, Arc<User>>,
    
    // スタック：キャッシュ設定
    max_size: usize,
    ttl_seconds: u64,
}

impl UserCache {
    fn get_or_fetch(&mut self, id: i64) -> Arc<User> {
        if let Some(user) = self.cache.get(&id) {
            // キャッシュヒット：クローンではなく参照カウントを増やす
            Arc::clone(user)
        } else {
            // キャッシュミス：DBから取得
            let user = fetch_user_from_db(id);
            let user_arc = Arc::new(user);
            self.cache.insert(id, Arc::clone(&user_arc));
            user_arc
        }
    }
}
```

### チャットアプリケーション

```rust
// メッセージ構造体の設計
struct Message {
    // ヒープ：メッセージ内容は可変長
    content: String,
    
    // ヒープ：ユーザー名も可変長
    author: String,
    
    // スタック：タイムスタンプは固定サイズ
    timestamp: i64,
    
    // スタック：メッセージIDは固定サイズ
    id: u64,
    
    // ヒープ：添付ファイルは任意数
    attachments: Vec<String>,
}

// チャットルーム
struct ChatRoom {
    // ヒープ：メッセージ履歴は増え続ける
    messages: Vec<Message>,
    
    // ヒープ：参加者リストも可変
    participants: Vec<String>,
    
    // スタック：ルーム設定は固定サイズ
    max_participants: usize,
    is_private: bool,
}
```

### ゲーム開発での例

```rust
// プレイヤーの状態
struct Player {
    // スタック：基本ステータス
    health: i32,
    mana: i32,
    level: u8,
    position: Vector3,
    
    // ヒープ：可変長のデータ
    name: String,
    inventory: Vec<Item>,
    skills: Vec<Skill>,
    quest_log: Vec<Quest>,
}

// ゲームワールド
struct GameWorld {
    // スタック：世界の基本設定
    width: u32,
    height: u32,
    gravity: f32,
    
    // ヒープ：動的なエンティティ
    players: Vec<Player>,
    enemies: Vec<Enemy>,
    items: Vec<DroppedItem>,
}
```

## パフォーマンスを考慮した選択

### 非効率な例 ❌

```rust
// 小さいデータを無駄にヒープに置く
fn inefficient_point() -> Box<Point2D> {
    Box::new(Point2D { x: 10.0, y: 20.0 })  // 不要なヒープ割り当て
}

// 大きな配列をスタックに置く
fn inefficient_buffer() -> [u8; 1_000_000] {
    [0; 1_000_000]  // スタックオーバーフローの危険
}

// 頻繁に作成・破棄される小さなデータをヒープに
fn inefficient_temp_data() {
    for i in 0..1000 {
        let temp = Box::new(i);  // 1000回のヒープ割り当て
        println!("{}", temp);
    }
}
```

### 効率的な例 ✅

```rust
// 小さいデータはスタックに
fn efficient_point() -> Point2D {
    Point2D { x: 10.0, y: 20.0 }  // スタック上で返す
}

// 大きなデータはヒープに
fn efficient_buffer() -> Vec<u8> {
    vec![0; 1_000_000]  // ヒープに割り当て
}

// 一時データはスタックで処理
fn efficient_temp_data() {
    for i in 0..1000 {
        println!("{}", i);  // スタック上の値を直接使用
    }
}
```

## 選択の指針

### 1. デフォルトはスタック
- まずはスタックを検討
- サイズが小さく固定ならスタック

### 2. 以下の場合はヒープを検討

| 条件 | 理由 | 例 |
|------|------|-----|
| サイズが不明 | コンパイル時にサイズが決まらない | ユーザー入力、ファイル読み込み |
| サイズが可変 | 実行中にサイズが変わる | 動的配列、文字列の連結 |
| データが大きい | スタックサイズの制限（通常8MB程度） | 画像データ、大量のレコード |
| 所有権の転送 | 関数やスレッド間での受け渡し | 非同期処理、並列処理 |
| 長いライフタイム | スコープを超えて存在する必要 | グローバルな状態、キャッシュ |

### 3. ハイブリッドアプローチ

```rust
// 設定管理の例
struct AppConfig {
    // スタック：固定の数値設定
    max_connections: u32,
    timeout_seconds: u16,
    retry_count: u8,
    
    // ヒープ：可変長の文字列設定
    server_url: String,
    api_key: String,
    
    // ヒープ：動的なリスト
    allowed_origins: Vec<String>,
}

// WebAPIレスポンスの例
struct ApiResponse {
    // スタック：HTTPステータス
    status_code: u16,
    
    // スタック：レスポンス時間
    response_time_ms: u32,
    
    // ヒープ：レスポンスボディ
    body: String,
    
    // ヒープ：ヘッダー情報
    headers: HashMap<String, String>,
}
```

## まとめ

適切な選択により：
- **パフォーマンス向上**: スタックは高速アクセス
- **メモリ効率**: 必要な分だけヒープを使用
- **安全性**: Rustの所有権システムが自動管理
- **保守性**: 意図が明確なコード

基本方針：
1. 小さく固定サイズ → スタック
2. 大きくて可変サイズ → ヒープ
3. 迷ったら測定して決める